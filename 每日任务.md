# day 01 

## 项目描述
    1). 这是一个关于哪方面的项目?
    2). 有哪些功能模块, 你负责哪些?
    3). 技术栈是哪些?
    4). 开发方式的特点?

## 技术选型
    1). 前台数据处理/交互/组件化
    2). 前后台交互
    3). 模块化
    4). 项目构建/工程化
    5). css预编译器
    6). 其它

## 接口相关理解
    1). 接口
    2). 接口文档
    3). 对/调/测接口 / 联调
    4). 前后台分离
    5). mock数据/接口

## 使用脚手架创建项目并运行
    1). 使用vue-cli3/4
    2). 开发环境运行
    3). 生产环境打包运行

## 引入less
    1). 下载less / less-loader
    2). <style lang="less">

## 引入vue-router
    1). 下载vue-router
    2). 创建路由器, 定义路由, 配置路由器
    3). 解决相对路径引入公用样式的问题  ==> 使用以/开头的路径

## 使用git管理项目
    1). 如何在开发/个人分支上处理
        创建并切换到本地开发分支: git checkout -b dev
        推送到远程, 产生远程的开发分支: git push origin dev
    2). 其他人如何得到dev分支
        git clone https://github.com/zxfjd3g/191121_gshop-client.git
        git checkout -b dev origin/dev
    3). 将开发分支合并到master分支
        合并本地分支: 
            git checkout master
            git merge dev
        推送到远程
            git push origin master
    4). 解决冲突
        当推送新的代码时, 如果远程已经有别的同事推送的同一个文件  ==> 推送就会失败
        解决: 先pull远程的更新到本地: git pull origin dev   ===> 如果修改了同一个文件就会有冲突
        解决冲突: 修正冲突的内容  => git add . => git commit -m "xxx" => git push origin dev 
  
## Header组件
    使用vscode的beautify file插件对vue组件文件进行格式化
    处理图片
    处理reset样式
    跳转路由的2种基本方式
        声明式: <router-link to="">
        编程式: this.$router.push()/replace()
    面试问题: 编程式路由跳转到当前路由, 控制台抛出NavigationDuplicated的错误
        方案1: 在跳转时指定成功或失败的回调函数
        方案2: 修正Vue原型上的push和replace方法 (优秀)
    跳转路由携带参数
        params参数
        query参数
    面试问题: 如何指定params参数可传可不传?    
        path: '/search/:keyword?'
    面试问题: 指定params参数时可不可以用path和params配置的组合?
        不可以用path和params配置的组合
        只能用name和params配置的组件
    面试问题: 如果指定name与params配置, 但params中数据是一个"", 地址栏路径有问题
        如果有参数数据, 指定params
        如果没有参数数据, 不指定params

    面试问题: 路由组件能不能传递props数据?
        可以: 可以将query或且params参数映射/转换成props传递给路由组件对象
        实现: props: (route) => ({ keyword1: route.params.keyword, keyword2: route.query.keyword })

## Footer组件
    如何控制footer/header组件在部分路由组件上不显示?
    利用路由的meta配置:
        meta: {
          isHideFooter: true, // 标识footer是否隐藏
        }
        <Footer v-if="!$route.meta.isHideFooter"/>

## Home组件
    Home静态路由组件
    从Home组件中抽取各个子组件并使用
        全局组件
        局部组件

# day 02

## 今日任务
    1). ajax与后台交互
    2). vuex
    3). TypeNav动态组件(部分)


## 1. 使用postman测试接口
    1). 启动 ===> 选择登陆==> cancel ===> 进入主界面
    2). 输入url/参数进行请求测试
    3). 注意post请求体参数需要指定为json格式
    4). 保存测试接口 ==> 后面可以反复使用

## 2. ajax与后台交互
    1). 对axios进行二次封装: api/ajax.js
        1. 配置通用的基础路径和超时
        2. 显示请求进度条
        3. 成功返回的数据不再是response, 而直接是响应体数据response.data
        4. 统一处理请求错误, 具体请求也可以选择处理或不处理
    2). 定义接口请求函数: api/index.js
        内部调用ajax函数
        函数的返回值是promise
    3). 调用接口请求函数发请求
        使用async/await简化promise的使用
    4). 配置代理解决跨域问题
        在vue.config.js中配置

## 3. 引入vuex并使用
    1). 下载vuex
    2). vuex的基本使用
    3). vuex多模块编程
        什么时候用? 当vuex管理的数据个数很多时
        好处: 每个功能模块的数据单独管理, 更方便, 更有扩展性
    4). vuex多模块编程的总state结构
        {
            user: {
                userInfo: {}
            },
            home: {
                baseCategoryList: []
            }
        }
    5). vuex与api交互
        异步action: 调用api接口请求函数  ==> 成功之后commit  ===> 调用mutation  ==> 更新状态数据

## 4. TypeNav组件
    1). 组件与vuex交互, 动态显示3级分类
        a. 触发异步action执行, 将数据从接口请求获取到state中: this.$store.dispatch(action)
        b. 通过mapState()/mapGetters()来将vuex中的数据读取到组件的计算属性
        c. 在模板中显示读取到的计算属性数据

    2). 控制2/3级分类列表的显示与隐藏
        @mouseenter  ==> 显示当前一级分类的2/3级分类
        @mouseleave  ==> 隐藏当前一级分类的2/3级分类
        设计一个标识当前分类下标的数据: currentIndex=-1
        当前分类的类名: :class="{item_on: currentIndex===index}"
        item_on类的样式: 背景色 / 下级列表display: block

    3). 点击某个分类项, 跳转到search路由: 
        携带query参数: /search?categoryName=电子书刊&category2Id=1
            categoryName: xxx
            category1Id: 1级分类ID / category2Id: 2级分类ID / category3Id: 3级分类ID
        解决方案一: 使用<router-link :to="{path: '/search', query: {...}}">
            问题: 效率太低(创建了太多的RouterLink组件对象, 内部绑定了太多的点击监听)  
    
# day 03

## 今日任务
    1). TypeNav动态组件
    2). mock数据接口
    3). 利用mock数据实现动态ListConter组件与Floor组件

## TypeNav动态组件
### 利用lodash库对高频触发的事件进行函数节流处理
    1). 理解区别函数节流与函数防抖(面试问题)
    2). 使用lodash进行函数节流与防抖编码处理
    3). 使用lodash对子列表显示切换进行节流处理

### 对lodash库实现按需引入, 减小打包文件
    1). 只引入要用的工具函数, 实现对lodash实现按需引入打包
    2). 好处: 减小打包文件, 访问更快

### 利用事件委托, 优化事件处理效率
    1). 给多个需要绑定事件的元素的共同父元素绑定事件监听
    2). 在事件回调函数中取出发生事件的元素: event.target
    3). 判断此元素是多个目标元素中的某个才进行处理

### 利用标签自定义属性携带动态数据
    1). 在发生事件的标签指定以data-xXX开头的属性
      <a :data-categoryName="c3.categoryName" :data-category3Id="c3.categoryId"></a>
    2). 在事件回调函数通过event得到标签, 从而取出自定义属性值
      const value = event.target.dataset.xxx
      注意: xxx是全小写的  ===> 当前得到2个属性: categoryname / category3id
    

### 控制1级列表的显示与隐藏
    1). 需要一个控制一级列表显示的状态数据: isShowFirst
    2). 在首页一直显示, 在搜索页面默认是隐藏的: 
        在mounted()中根据根据当前请求的路径判断, 如果是不是首页隐藏
        在mounseleve中  ==> 如果当前不是首页,隐藏一级列表
        在mouseenter中  ==> 显示一级列表

### 优化请求执行的位置, 减少请求次数
    问题: 切换路由组件会发多次获取分类列表的请求?
    原因: 触发请求的代码写在TypeNav组件中, 每渲染一次, 就会发一次请求
    解决: 触发请求的代码写在App中就可以

## mock数据接口
    问题: 首页只有分类列表的接口, 其它数据的接口还没有写好, 咋办?
    解决: 自己mock数据接口

### 设计json数据
    json数据的组成
        结构: 类型和名称  本身是不会显示在页面上
        值: 就是可以显示在页面上的数据
    mock数据与真实数据关系?
        结构尽量一致, 值可以变

### 如何实现mock?
    使用mockjs库: Mock.mock(url, template)
    定义针对mock接口的ajax封装: mockAjax.js
    定义针对mock接口的接口请求: api/index.js
    定义针对mock数据的vuex模块: store/modules/home.js
    在组件中触发获取mock数据: this.$store.dispatch('getBanners')


## 利用mock数据实现动态ListConter组件与Floor组件

### 使用swiper库实现静态轮播图效果
    下载swiper: npm install swiper -S
    使用: 
        引入包(js/css)
        标签结构
        创建Swiper对象: 必须在列表数据显示之后创建才正确
    bug: 
        问题: 创建的swiper会对其它组件界面中的swiper界面产生影响
        原因: new Swiper('.swiper-container'),  类选择会匹配上页面中的所有此类名元素, 就会都产生效果
        解决: 使用vue的ref技术来指定swiper的根元素

### 使用swiper库实现动态轮播图效果
    动态获取数据并显示到轮播页面中
    如果在mouted()中创建swiper对象, 轮播有问题
        原因: banners数据是异步获取, 而mounted很早就执行了, 创建swiper对象是在列表数据显示之前
        解决方案1: 定时器延迟一定时间执行  ==>此方案不可用
            延迟的时间不太能确定, 因为请求返回数据的时间不确定
        解决方案2: watch + $nextTick ==>此方案不可用
            通过watch就能知道banners数据发生了改变 [] ==> [{}, {}]
            通过$nextTick(callback)能知道界面因为这个数据发生改变而更新
        // 解决方案3: callback + $nextTick   后面合适时机再说
        
### 抽取可复用的轮播组件Carousel
    将ListContainer中swiper的模板页面和JS部分拿过来
    定义接收轮播数组数据: carouselList, 并显示
    在ListContainer和Floor组件中使用Carousel: <Carousel :carouselList="array">

    为什么Foor组件中的轮播有问题? 
        v-for遍历的如果是空数组, 不会渲染组件标签
        floors开始是[] ==> 初始显示没有渲染Foor组件  ==> 没有渲染它内部的Carousel 
                ==> 没有创建Carousel对象
        后面异步获取了foors数组([{}, {}]) ===> 渲染2个Floor 
                ==> 渲染2个它内部的Carousel ==> 创建Carousel对象 ===> 调用mounted(), 有数据的长为3
                没有更新的过程  ==> 不会执行watch的回调
    为什么ListContainer中的没问题?
        banners为空数组 ==> 渲染Carousel ===> 创建Carousel, 调用mounted, 没有数据(长度为0)
        异步获取banners数组 ==> 更新渲染Carousel ===> 调用watch的回调函数
    解决办法:
        利用watch的immediate: true
        在初始显示时就立即执行一次, 默认是false(只有数据改变才立即执行)
    导致新的执行效率问题?
        问题: ListContainer中的轮播的swiper对象多创建了
        解决: 只有当数组中有数据才创建: if (this.carouselList.length===0) return


# day 04

## 今日任务: 实现Search组件
    1)复杂的查询参数准备
    2)响应式数据对象: 添加新属性与删除属性的问题
    3)query参数与params参数的控制(添加/删除/携带)
    4)全局事件总线进行任意组件间通信, vue自定义事件进行子向父通信
    5)切换排序方式的逻辑处理
    6)自定义分页组件

### 搜索条件参数分析
		category1Id:  一级分类ID
		category2Id:  二级分类ID
		category3Id:  三级分类ID
		categoryName: 分类名称
		keyword:     搜索关键字
		trademark:   品牌ID:品牌名称
		order:       排序方式  综合1,价格2 升序asc,降序desc"2:desc"
		pageNo:      当前第几页
		pageSize:    每页最多显示多少条数据	
		props: 		 多个属性条件组件的数组[‘属性ID:属性值:属性名’]
				[
					"2:6.65-6.74英寸:屏幕尺寸",
					"4:16GB:机身存储"
				]
				理解: 商品属性包含: 属性id, 属性名, 多个属性值的数组 

### ajax + vuex

### 在组件中动态显示: 品牌列表 + 属性列表 + 商品列表

### 根据分类和关键字进行搜索
		基本实现
			1). 分类搜索参数: query参数 categoryName / category1Id / category2Id / category3Id
			2). 关键字搜索参数: params参数 keyword
			3). Search组件得到分类/关键字参数并发搜索请求
				mounted() 中处理     从首页跳转到搜索
				watch ==> $route()   在搜索页改变分类或关键字
				利用...合并多个参数数据
		功能bug: 
			问题1描述:
				在搜索页面, 再改变分类或改变关键时, 参数携带有问题
				本来有分类条件 ==> 指定关键字条件  ==> 分类条件就会丢失
				本来有关键字条件 ==> 指定分类条件 ==> 关键字条件就会丢失
			原因:
				根据分类跳转时, 没有携带包含keyword的params参数
				根据关键字进行跳转时, 没有携带包含分类数据的query参数
			解决办法
				1). 判断是在搜索界面
				2). 指定需要携带params或者query参数
				3). 指定replace的跳转方式
				
			问题2描述:
				切换到另一个级别的分类, 原分类的id数据依然还在
			原因:
				没有去重置分类条件数据
			解决:
				在$route的监视回调中, 重置options中的分类相关数据

		删除分类/关键字条件
			问题1. : 地址栏的参数没有同步变化?
			解决: 通过replace()重新跳转到当前搜索界面, 去除params或者query参数
		
		问题: 删除关键字条件时, Header中的关键输入没有清除
		原因: 输入的数据没有做清除处理
		解决: 使用全局事件总线$bus来实现Search组件与Header组件间通信

### 品牌条件的设置与删除
		品牌条件数据的结构: 品牌id:品牌名称
		父子组件间通信
				父向子: 传递一般(非函数)属性
				子向父: 传递函数属性

### 属性条件的添加与删除
		防止添加重复的属性条件


### 排序方式的动态显示与切换
		排序条件数据的结构:
				order: '1:desc'  综合降序
				order: '1:asc'  综合升序
				order: '2:desc'  价格降序
				order: '2:asc'  价格升序
		确定哪个排序项需要选中?
				:class="{active: isActive ('1') }"
		点击切换排序?
				切换排序项: 综合/价格    如果当前排序标记不等于指定的标记
				切换排序方式: 升序/降序  如果当前排序标记等于指定的标记
		动态显示排序方式图标?
				不需要显示   如果当前排序标记不等于指定的标记
				显示升/降的图标   如果当前排序标记等于指定的标记

# day 05

## 今日任务
    1). 自定义通用的分页组件
    2). 商品详情Detail路由界面

## 自定义通用的分页组件

### 使用已定义好的分页组件
    <Pagination :pageConfig="{
            total: productList.total,  // 总数据个数
            showPageNo: 3,   // 连续页码
            pageNo: options.pageNo, // 当前第几页
            pageSize: options.pageSize // 每页最多几条数据
        }"
        @changeCurrentPage="getProductList"
    />

### 设计通用组件的基本思路  (面试题, 非常重要)
    基本的界面布局
    设计内部状态数据 : 
        currentPage: 当前页码
    设计接收哪些动态属性数据:
        pageConfig: {  
          total: 0, // 总记录数量
          pageSize: 10, // 一页最多显示多条记录
          pageNo: 1, // 当前在第几页
          showPageNo: 5, // 连续显示的页码数
        }
    实现组件内部的交互效果
        绑定监听  => 更新数据 ==> 组件界面更新
    设计当内部发生数据改变时, 通知外部父组件: 可以用vue自定义事件或函数属性来实现
        // 保存当前页码
        this.currentPage = currentPage
        // 分发自定义事件
        this.$emit('changeCurrentPage', currentPage)
    当外部组件传入的数据发生改变时, 内部数据可能也需要变化
        使用watch来监视外部数据的变化 ==> 同步修改内部数据

### 实现
    使用vue相关技术:
        data / props / computed
        绑定事件监听 / methods
        watch / 分发自定义事件
    难点:
        计算: 总页数totalPages / 连续页码的start和end
        连续页码的显示: v-for + v-if  ===> v-for的优先级最高, v-if在遍历过程中执行多次    面试题

## 商品详情Detail路由界面

### ajax + vuex

### 动态显示商品部分信息
    dispatch()
    mapState() / mapGetters()



# day 06    

## 今日任务
    1). 放大镜组件: Zoom
    2). 购物车路由

## 放大镜组件: Zoom   面试交流
    布局设计:
        左侧:
            <div> / <img> / mask的<div>
        右侧: 
            <div> / <img>
    mousemove事件处理
        加在左侧div
        计算left和top
            事件的坐标: offsetX  / offsetY
            mask的宽度maskWidth: div的宽度/2 ===> 在mounted()中确定这个值
        指定mask div的left和top
        指定右侧img的-2*left和-2*top

## 购物车路由
### 初始显示报错
    问题: Cannot read property 'imgUrl' of undefined"
    原因: 模板中有3层表达式(a.b.c), 如: skuImageList[currentImgIndex].imgUrl
         skuImageList的初始值为[], 这个3层表达式在初始解析时就会报错
    解决: 利用v-if来判断限制初始没有数据时解析: v-if="skuImageList.length>0"

### sessionStorage与locaStorage区别?  面试题
    相同点:
        都纯浏览器端存储
        语法一样: setItem(key, value)/getItem(key)/removeItem(key)
    不同点: 
        sessionStorage: 
            存在于浏览器的运行时内存中  ==> 浏览器关闭数据被清除, 重新打开读取不到
            操作相对快些
        locaStorage: 
            保存在浏览器管理的本地文件中  ==> 浏览器关闭再打开还在可以读取到
            操作相对慢些

### 如何根据分发异步action的成功或失败做不同处理?
    1). 方式一: 使用callback: 
        1). 在组件中: 在dispatch时指定一个回调函数数据
        2). 在异步action中: 在请求处理成功或失败后, 调用callback, 并传入errorMsg(可能有值或没有)
        3). 在回调函数:  如果接收的errorMsg有值, 提示错误, 否则做成功后的处理 
    2). 方式二: 利用async函数
        前提: async函数执行的返回值是一个promise对象
            promise成功的value: 函数体执行没有出错, 那return的就是value(不能是失败的promise)
            promise失败的reason: 函数体执行出错/抛出error/返回一个失败的promise
            store.dispatch()的返回值就是action函数的返回值
        1). 在组件中: 正常分发action: this.$store.dispatch('addToCart2', query)
        2). 在异步action中: 在请求处理成功或失败后, 返回相关的errorMsg(可能有值或没有)
            return result.code===200 ? '' : (result.message || '添加购物车失败')
        3). 在组件中: 通过await来得到errorMsg, 根据它来做相应处理

### 所有ajax请求都需要携带用户临时ID数据  面试讲解
    1). 理解userTempId的特点
        每个客户端应该不相同
        同一个客户端应该不要发生变化, 如果中途变化了, 前面通过userTempId保存在后台的数据就找不到了
    2). userTempId的生成和保存
        生成: 使用uuidjs生成一个随机唯一值(与别人不同, 与我前面生成的也不一样)
        保存: 
            持久化保存: 将userTempId保存到localStorage中
            内存中保存: 将userTempId也保存在vuex的状态中  (为了更快的读取)
            state = {
                userTempId: getUUID()  // 如果local中没有生成一个新的并保存, 如果有直接返回
            }
    3). 发送请求时携带已保存的userTempId
        在请求拦截器中: 读取state中保存的userTempId, 并添加到请求头中
        config.headers['userTempId'] = store.state.user.userTempId

### 路由组件间传递数据
    1). query参数
    2). params参数
    3). sessionStorage
    4). vuex


# day 07


## 今日任务
    1). 购物车数据管理
    2). 注册与登陆

## 购物车数据管理

### 删除指定购物项
    异步action中:  请求删除失败, 抛出包含提示文本的Error对象 
    在组件中: dispatch()之后通过返回promise的成功或失败来做相应处理
        如果成功: 重新获取购物项列表
        如果失败: 提示文本

### 删除所有选中的购物项
    得到所有选中: 利用数组的filter()/reduce()
    遍历每个购物项, 分别都去dispatch()请求删除对应的购物项  (没有一次删除多个购物项的接口)
        利用到数据的forEach() / reduce() / map()
    通过Promise.All(promises)来确定是否都成功
        如果都成功了: 重新获取购物项列表
        如果失败: 提示文本

### 改变某个购物项的选中状态
    组件化编码更新数据的基本原则: 
        组件只直接更新自己的数据, 不要直接别人(父组件/vuex)数据 
    组件中根据从vuex读取的数据来显示是否勾选
        :checked="item.isChecked"
    组件中当用户改变了勾选, 将最新的勾选状态同步到vuex中(可能要发请求)
        @change="checkCartItem(item)"
        根据dispatch()返回的promise是否成功做相应处理

### 改变所有购物项的选中状态
    遍历所有购物项, 多次调用dispatch()删除多个购物项
    通过Promise.All(promises)来确定是否都成功并做相应处理

### 修改某个购物项的数量
    区别<input type="text">的change与input监听
        change事件: 输入框失去焦点才触发     input事件监听 ===>输入改变时触发
        input事件: 输入发生改变时触发
    action函数的参数: changeItemNum({commit, state, dispatch}, data) {}
        commit: 执行触发mutation调用
        state: 读取当前的状态数据
        dispatch: 执行触发action调用
    在action中
        请求修改
        成功了: dispatch('getCartList')获取新的购物车数据
        失败了: 直接提示

### 图形验证码总是验证失败
    原因:
        显示图形验证码: 
            http://182.92.128.115/api/user/passport/code
            浏览器直接发送了这个请求, 并没有经过代理服务器
            后台生成一个一个code值, 保存在后台, 并以图片的形式返回给浏览器显示
        发注册请求:
            通过代理服务器发送请求, 传过去了code / mobile / password
            后台要读取对应的code与传过去的code进行对比
            由于2次请求不是现一个人(一般http引擎与ajax引擎), 后台找不到对应的code
            比较的结果总code不正确
    解决:
        获取验证码的请求与注册的请求都通过代理服务发送
        不要写完整路径, 而只要写一个让代理服务器能匹配并处理的路径 

# day 08

## 今日任务
    1). 登陆 & 退出登陆 & 自动登陆
    2). 订单/支付路由跳转流程
    3). 导航守卫


## 登陆 & 退出登陆 & 自动登陆

### 登陆
    收集用户输入的mobile和password数据, 并进行前台表单校验
    提交登陆的请求
    如果失败, 提示
    如果成功, 
        将得到的用户信息(包含token)保存到vuex和local中
        跳转到首页 ==>后面需要完善

### 退出登陆
    请求后台清除后台记录的用户信息
    清除内存和local保存的用户信息

### 自动登陆
    方式一： 登陆时将用户的所有信息(用户名/token)保存到local 
        ==> 不需要额外发请求就可以(读取local中的数据)实现自动登陆
    方式二： 登陆时只将token保存到local
        ===> 需要根据local中保存的token发请求获取对应的用户信息

### 组件什么时候会自动更新?
    简单表达: 当模板中使用的响应式数据发生了任何变化
    哪些响应式数据:
        data
        props
        vuex: state与getters
        computed

        this.xxx = 123    {{xxx}}
        this.xxx = 345   不会自动更新的

### 区别：userTempId与token
    1). userTempId: 浏览器端生成， 用于标识一个未登陆的客户端， 每次请求(尤其是购物车)都携带userTempId
    2). token: 请求登陆成功时服务器返回给浏览器保存的, 用于标识这个登陆用户, 每次请求如果有token, 需要自动携带
    3). 在购物车中的应用
        1). 在未登陆前: 购物车数据的提交和获取依赖于userTempId
        2). 在登陆后: 购物车数据的提交和获取依赖于token
        3). 第一次同时携带token和userTempId获取购物时, 后台会将userTempId下的购物项转移到当前用户下下, 其实后面只需要token就可以得到所有的购物项
        如果退出登陆, 通过userTempId, 不能再得到前面与它对应的数据

## 导航守卫
### 导航守卫的理解
    vue-router提供的用来监视和控制路由跳转的一套功能技术

### 导航守卫的分类
    全局守卫: 针对任意路由跳转
        a. 全局前置守卫  router.beforeEach((to, from, next) => { })
        b. 全局后置守卫
	路由守卫: 只针对当前组件的路由跳转
		前置守卫  router.afterEach((to, from) => { })
    组件守卫: 只针对当前组件的路由跳转
        a. 进入: beforeRouteEnter (to, from, next) { },  // 注意回调函数中的this为undefined
        b. 更新
        c. 离开
### 注意:
    理解to/from/next
    前置守卫是在到达目标路由前调用
    组件的前置守卫中的this为undefined, 如果想用组件对象可以: next((component) => {})

### 导航守卫在项目中的应用
    a.只有登陆了, 才能查看交易/支付/个人中心界面
        使用全局前置守卫: router.beforeEach()
    b.只有没有登陆, 才能查看登陆界面
        使用路由独享前置守卫: beforeEnter()
        使用组件前置守卫: beforeRouteEnter()
    c.只有携带的skuId和skuNum以及sessionStorage中有skuInfo数据, 才能查看添加购物车成功的界面
    d.只能从购物车界面, 才能跳转到交易界面
    e.只能从交易界面, 才能跳转到支付界面
    f.只有从支付界面, 才能跳转到支付成功的界面

### 登陆成功后, 自动跳转到前面你想访问但因为没登陆而没有成功跳转的路由?
    在全局前置守卫强制跳转到登陆时携带目标路径的query参数: redirect=目标路径
    在登陆成功后, 跳转到redirect参数所指向的路径

## 订单/支付路由跳转流程
    购物车 => 订单交易 => 支付 => 支付成功 => 我的订单列表
    二级路由的搭建 
### 什么时候需要拆分子路由了?
    如果一个路由组件界面上有其局部界面的切换显示


# day 09

## 今日任务
    1). 订单交易
    2). 支付
    3). 我的订单列表

## 我的订单列表
    如何使组件中能方便的调用接口请求函数(不需要引入)
        import * as API from './api'  // 引入包含所有接口请求函数方法的对象
        // 将API对象挂载到Vue原型对象上
        Vue.prototype.$API = API  // 所有的组件中都可以通过this.$API来访问

    在组件中调用接口函数处理
        在data中定义对应的数据
        mounted()中调用接口请求函数获取数据  ==> 更新到data中
        模板读取data中的数据显示

    多个标签进行统一控制: 
        办法1: 在外层添加一个<div>, 通过控制div伙控制多个标签
            问题: 多产生一层不必要的标签  ==> 效率低/样式可能有问题
        办法2: 可以在外层添加一个<template>
            <template>不会生成对应的HTML标签, 不会出现在界面上


## 订单交易
    动态获取数据显示
    收件地址选择的功能
        默认选中默认收件地址  ==> 选中地址的默认值是默认收件地址
        点击选中任意一个
        显示选中的地址
    提交订单
        提交订单请求的参数准备


## 支付
    动态获取支付信息 ==> 支付的url
    利用qrcode查生成一个用于支付的二维码图片
    利用element-ui来将二维码以对话框的形式显示
        配置按需引入打包
        引用一些我们需要使用的组件
            标签组件: 注册组件标签
            函数组件: 需要挂载到Vue原型对象上
    请求获取订单状态, 如果是支付已完成, 自动跳转到支付成功页面
        每隔3S发一请获取状态请求, 只有已支付才结束, 并跳转
        循环定时器需要在合适的时机清除
    如何不点击取消或确定按钮, 关闭对话框
        this.$msgBox.close()

## 项目整体界面功能


